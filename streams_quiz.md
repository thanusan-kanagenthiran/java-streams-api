# Java Streams Quiz

This quiz contains 50 Multiple Choice Questions (MCQs) and 50 Structured Essay Questions on Java Streams. Answers are provided below each question for self-assessment. Focus on theoretical understanding.

## Multiple Choice Questions (MCQs)

### 1. What is the primary characteristic of Java Streams?
A) They store data in memory  
B) They are lazy and functional pipelines  
C) They modify the underlying data source  
D) They are always parallel  

**Correct Answer: B**  
Streams represent a sequence of elements supporting functional-style operations without storing data. Laziness ensures intermediate operations don't execute until a terminal operation is invoked.

### 2. Which method creates a sequential stream from a collection?
A) `parallelStream()`  
B) `stream()`  
C) `Arrays.stream()`  
D) `Stream.of()`  

**Correct Answer: B**  
`collection.stream()` returns a sequential stream reflecting the collection's encounter order.

### 3. What does the `filter` operation do?
A) Transforms elements  
B) Removes duplicates  
C) Retains elements matching a predicate  
D) Sorts elements  

**Correct Answer: C**  
`filter` retains only elements that match the given boolean condition (predicate).

### 4. Which is NOT an intermediate operation?
A) `map`  
B) `collect`  
C) `distinct`  
D) `sorted`  

**Correct Answer: B**  
`collect` is a terminal operation that accumulates elements into a result. Intermediate operations are lazy and return a stream.

### 5. What is the result of `Stream.of(1,2,3).count()`?
A) 1  
B) 2  
C) 3  
D) Optional[3]  

**Correct Answer: C**  
`count()` is a terminal operation that returns the number of elements in the stream as a long.

### 6. Which collector groups elements by a classifier?
A) `toList()`  
B) `joining()`  
C) `groupingBy()`  
D) `partitioningBy()`  

**Correct Answer: C**  
`groupingBy()` groups elements by a function and returns a Map.

### 7. When should you use parallel streams?
A) For I/O operations  
B) For CPU-intensive tasks on large data  
C) For small datasets  
D) When order matters  

**Correct Answer: B**  
Parallel streams are suitable for CPU-bound, stateless operations on large datasets, but not for I/O or ordered requirements.

### 8. What guarantees encounter order in parallel streams?
A) `forEach`  
B) `findAny`  
C) `forEachOrdered`  
D) `unordered()`  

**Correct Answer: C**  
`forEachOrdered` preserves encounter order in parallel streams, unlike `forEach`.

### 9. Which operation is short-circuiting?
A) `map`  
B) `filter`  
C) `findFirst`  
D) `collect`  

**Correct Answer: C**  
`findFirst` is a terminal short-circuiting operation that stops once the first element is found.

### 10. What does `flatMap` do?
A) Flattens nested collections  
B) Maps to a single value  
C) Removes elements  
D) Sorts elements  

**Correct Answer: A**  
`flatMap` maps each element to a stream and flattens all resulting streams into one.

### 11. Which stream type avoids boxing overhead?
A) `Stream<Integer>`  
B) `IntStream`  
C) `Stream<String>`  
D) `DoubleStream`  

**Correct Answer: B**  
`IntStream` is a primitive stream that avoids boxing/unboxing for int values.

### 12. What is the difference between `reduce` and `collect`?
A) `reduce` builds containers, `collect` aggregates  
B) `reduce` aggregates, `collect` builds containers  
C) Both are the same  
D) `reduce` is intermediate, `collect` is terminal  

**Correct Answer: B**  
`reduce` combines values into a single result (aggregation), while `collect` builds collections or structures.

### 13. Which method creates an infinite stream?
A) `Stream.of()`  
B) `Stream.generate()`  
C) `Arrays.stream()`  
D) `Stream.empty()`  

**Correct Answer: B**  
`Stream.generate(Supplier)` produces an infinite stream of elements generated by the supplier.

### 14. What does `peek` do?
A) Consumes the stream  
B) Performs an action without modifying  
C) Filters elements  
D) Maps elements  

**Correct Answer: B**  
`peek` performs an action on each element as it passes through, mainly for debugging, without altering the stream.

### 15. Which is a terminal operation?
A) `limit`  
B) `skip`  
C) `anyMatch`  
D) `map`  

**Correct Answer: C**  
`anyMatch` is a terminal matching operation that tests if any element matches a predicate.

### 16. What is lazy execution?
A) Operations execute immediately  
B) Intermediate operations wait for terminal  
C) Streams store data  
D) Parallel by default  

**Correct Answer: B**  
Laziness means intermediate operations are not executed until a terminal operation triggers the pipeline.

### 17. Which collector concatenates strings?
A) `toList()`  
B) `joining()`  
C) `groupingBy()`  
D) `summarizingInt()`  

**Correct Answer: B**  
`joining()` concatenates string elements, optionally with delimiters.

### 18. Can streams be reused?
A) Yes, always  
B) No, they are single-use  
C) Only parallel streams  
D) Only sequential streams  

**Correct Answer: B**  
Streams cannot be reused after a terminal operation; attempting to do so throws an exception.

### 19. What does `unordered()` do?
A) Reorders elements  
B) Hints order doesn't matter for optimization  
C) Sorts elements  
D) Preserves order  

**Correct Answer: B**  
`unordered()` relaxes ordering constraints, allowing optimizations without guaranteeing order.

### 20. Which operation removes duplicates?
A) `filter`  
B) `distinct`  
C) `limit`  
D) `skip`  

**Correct Answer: B**  
`distinct` removes duplicate elements using `equals`.

### 21. What is the result of `Stream.empty().count()`?
A) 0  
B) 1  
C) Null  
D) Exception  

**Correct Answer: A**  
`Stream.empty()` creates a stream with no elements, so `count()` returns 0.

### 22. Which is NOT a primitive stream?
A) `IntStream`  
B) `LongStream`  
C) `Stream<Double>`  
D) `DoubleStream`  

**Correct Answer: C**  
`Stream<Double>` is an object stream, not primitive; `DoubleStream` is primitive.

### 23. What does `takeWhile` do?
A) Takes all elements  
B) Takes while predicate is true (Java 9+)  
C) Drops elements  
D) Limits to n elements  

**Correct Answer: B**  
`takeWhile` takes elements as long as the predicate holds, then stops.

### 24. Which method switches to parallel?
A) `sequential()`  
B) `parallel()`  
C) `unordered()`  
D) `close()`  

**Correct Answer: B**  
`parallel()` switches the stream to parallel execution mode.

### 25. What is encounter order?
A) Processing order  
B) Source element order  
C) Result order  
D) Random order  

**Correct Answer: B**  
Encounter order is the order in which elements are produced by the data source.

### 26. Which collector partitions elements?
A) `toList()`  
B) `joining()`  
C) `groupingBy()`  
D) `partitioningBy()`  

**Correct Answer: D**  
`partitioningBy()` splits elements into two groups based on a predicate.

### 27. What does `findAny` do in parallel streams?
A) Always finds the first  
B) May return any element non-deterministically  
C) Sorts first  
D) Finds the last  

**Correct Answer: B**  
In parallel streams, `findAny` is optimized for concurrency and may return any matching element.

### 28. Which is an aggregate operation?
A) `filter`  
B) `map`  
C) `count`  
D) `peek`  

**Correct Answer: C**  
`count` is a terminal aggregate that returns the number of elements.

### 29. What is the purpose of `spliterator`?
A) Creates streams  
B) Provides traversal  
C) Collects elements  
D) Filters elements  

**Correct Answer: B**  
`spliterator` provides a way to traverse and partition elements for parallel processing.

### 30. Which operation is stateful?
A) `filter`  
B) `map`  
C) `distinct`  
D) `limit`  

**Correct Answer: C**  
`distinct` is stateful as it tracks seen elements; `filter` and `map` are stateless.

### 31. What does `summaryStatistics` return?
A) A single value  
B) A summary object  
C) A list  
D) A map  

**Correct Answer: B**  
`summaryStatistics` returns an object with count, sum, min, average, max.

### 32. Which is NOT a short-circuit operation?
A) `findFirst`  
B) `anyMatch`  
C) `collect`  
D) `limit`  

**Correct Answer: C**  
`collect` is not short-circuiting; it processes all elements. `findFirst`, `anyMatch`, `limit` are.

### 33. What does `concat` do?
A) Splits streams  
B) Combines two streams  
C) Filters streams  
D) Maps streams  

**Correct Answer: B**  
`Stream.concat(a, b)` combines two streams sequentially.

### 34. Which stream is infinite by default?
A) `Stream.of()`  
B) `Stream.iterate()`  
C) `Arrays.stream()`  
D) `Stream.empty()`  

**Correct Answer: B**  
`Stream.iterate()` produces an infinite stream unless limited.

### 35. What is the role of `combiner` in `collect`?
A) Filters elements  
B) Combines partial results in parallel  
C) Maps elements  
D) Terminates the stream  

**Correct Answer: B**  
In parallel reduction, the combiner merges results from different threads.

### 36. Which operation preserves order in parallel?
A) `forEach`  
B) `findAny`  
C) `forEachOrdered`  
D) `unordered`  

**Correct Answer: C**  
`forEachOrdered` ensures encounter order is preserved in parallel streams.

### 37. What does `boxed` do?
A) Unboxes primitives  
B) Boxes primitives to objects  
C) Filters primitives  
D) Sums primitives  

**Correct Answer: B**  
`boxed()` converts a primitive stream to an object stream, e.g., `IntStream` to `Stream<Integer>`.

### 38. Which is a reduction operation?
A) `filter`  
B) `reduce`  
C) `peek`  
D) `limit`  

**Correct Answer: B**  
`reduce` is a terminal reduction that combines elements into a single result.

### 39. What is the default pool for parallel streams?
A) Custom pool  
B) ForkJoinPool.commonPool()  
C) Thread pool  
D) Single thread  

**Correct Answer: B**  
Parallel streams use `ForkJoinPool.commonPool()` by default.

### 40. Which collector is concurrent?
A) `toList()`  
B) `groupingBy()`  
C) `groupingByConcurrent()`  
D) `joining()`  

**Correct Answer: C**  
`groupingByConcurrent()` is optimized for parallel streams but doesn't preserve order.

### 41. What does `dropWhile` do?
A) Takes elements  
B) Drops while predicate is true (Java 9+)  
C) Limits elements  
D) Sorts elements  

**Correct Answer: B**  
`dropWhile` skips elements as long as the predicate holds, then processes the rest.

### 42. Which operation is non-interfering?
A) Modifies source  
B) Doesn't modify source  
C) Consumes stream  
D) Creates stream  

**Correct Answer: B**  
Non-interfering operations do not modify the underlying data source.

### 43. What is the result of `Stream.of(1).findFirst()`?
A) 1  
B) Optional[1]  
C) List[1]  
D) Stream[1]  

**Correct Answer: B**  
`findFirst` returns an `Optional<T>`.

### 44. Which is NOT a collector?
A) `toList`  
B) `joining`  
C) `filter`  
D) `groupingBy`  

**Correct Answer: C**  
`filter` is an intermediate operation, not a collector.

### 45. What does `range` generate?
A) Random numbers  
B) Sequential numbers  
C) Infinite numbers  
D) String ranges  

**Correct Answer: B**  
`IntStream.range(0, 5)` generates 0,1,2,3,4.

### 46. Which operation can throw exceptions?
A) `map`  
B) `filter`  
C) Lambdas in operations  
D) `count`  

**Correct Answer: C**  
Lambdas in operations like `map` or `filter` can throw runtime exceptions.

### 47. What is the purpose of `onClose`?
A) Opens streams  
B) Registers cleanup handlers  
C) Closes streams  
D) Creates streams  

**Correct Answer: B**  
`onClose` registers a handler to run when the stream is closed.

### 48. Which is stateful intermediate?
A) `map`  
B) `filter`  
C) `sorted`  
D) `peek`  

**Correct Answer: C**  
`sorted` is stateful as it buffers elements to sort.

### 49. What does `partitioningBy` return?
A) A list  
B) A map with two entries  
C) A set  
D) A single value  

**Correct Answer: B**  
`partitioningBy` returns a `Map<Boolean, List<T>>` with true and false keys.

### 50. Which stream method is for I/O?
A) `Files.lines()`  
B) `Stream.of()`  
C) `Arrays.stream()`  
D) `Stream.generate()`  

**Correct Answer: A**  
`Files.lines(path)` creates a stream from file lines, requiring resource management.

## Structured Essay Questions

### 1. Explain the concept of laziness in Java Streams and provide an example of how it optimizes performance.

**Answer:**  
Laziness in Java Streams means that intermediate operations (like `filter`, `map`) are not executed until a terminal operation (like `collect`) is invoked. This allows the stream to optimize the entire pipeline, potentially skipping unnecessary computations. For example, in `stream.filter(x -> x > 10).map(x -> x * 2).findFirst()`, only the first element greater than 10 is processed and doubled, not the entire stream.

### 2. Describe the difference between sequential and parallel streams, including when to use each.

**Answer:**  
Sequential streams process elements one by one in a single thread, preserving encounter order. Parallel streams split the data into chunks processed concurrently using ForkJoinPool, improving performance for CPU-intensive tasks on large datasets but not guaranteeing order. Use sequential for small data, I/O, or when order matters; parallel for large, stateless CPU-bound tasks.

### 3. What are intermediate and terminal operations? Give examples and explain their execution model.

**Answer:**  
Intermediate operations (e.g., `filter`, `map`, `sorted`) transform the stream lazily and return a new stream. Terminal operations (e.g., `collect`, `forEach`, `count`) trigger execution and produce a result. Intermediate ops don't run until a terminal op is called, enabling optimization.

### 4. Discuss the role of collectors in Java Streams and explain how `groupingBy` works.

**Answer:**  
Collectors accumulate stream elements into a mutable result container. `groupingBy` groups elements by a classifier function, returning a `Map<K, List<V>>`. For example, `stream.collect(groupingBy(Person::getCity))` groups people by city.

### 5. Explain short-circuiting operations and their importance for infinite streams.

**Answer:**  
Short-circuiting operations stop processing once the result is determined, avoiding infinite loops. Terminal examples: `findFirst`, `anyMatch`. Intermediate: `limit`. Crucial for infinite streams like `Stream.iterate(0, i -> i + 1)`, where `limit(5)` takes the first 5 elements.

### 6. What is encounter order, and why does it matter in parallel streams?

**Answer:**  
Encounter order is the sequence elements are produced by the source. In parallel streams, operations like `forEach` don't guarantee this order, potentially leading to non-deterministic results. Use `forEachOrdered` to preserve it.

### 7. Describe the `reduce` method with its three forms and provide examples.

**Answer:**  
`reduce` combines elements into a single result. Forms: `reduce(BinaryOperator)` returns Optional; `reduce(identity, BinaryOperator)` returns T; `reduce(identity, BiFunction, BinaryOperator)` for parallel. Example: `stream.reduce(0, Integer::sum)` sums elements.

### 8. How do primitive streams improve performance? Explain with `IntStream`.

**Answer:**  
Primitive streams like `IntStream` avoid boxing/unboxing overhead of converting int to Integer. `IntStream.range(1, 100).sum()` is efficient without object creation.

### 9. What are stateless and stateful operations? Give examples.

**Answer:**  
Stateless operations (e.g., `filter`, `map`) don't depend on previous elements. Stateful (e.g., `distinct`, `sorted`) require tracking state, potentially buffering elements.

### 10. Explain the pipeline concept in streams with a diagram in text.

**Answer:**  
Streams are functional pipelines: Data Source → Creation → Intermediate Ops → Terminal Op → Result. Laziness delays execution until terminal.

### 11. Discuss the implications of streams being single-use.

**Answer:**  
Streams are consumed after a terminal operation; reusing throws `IllegalStateException`. This enforces functional style and prevents side effects.

### 12. What is the difference between `findFirst` and `findAny`?

**Answer:**  
`findFirst` returns the first element in encounter order. `findAny` returns any element, optimized for parallel streams where order isn't guaranteed.

### 13. Explain how `flatMap` differs from `map`.

**Answer:**  
`map` transforms each element to one result. `flatMap` transforms to a stream and flattens, useful for nested collections like `list.stream().flatMap(Collection::stream)`.

### 14. Describe the `collect` method's three-argument form.

**Answer:**  
`collect(supplier, accumulator, combiner)`: Supplier creates container, accumulator adds elements, combiner merges containers in parallel.

### 15. Why are streams non-interfering, and what happens if they aren't?

**Answer:**  
Non-interfering means operations don't modify the source. Interfering can cause `ConcurrentModificationException` or unpredictable results.

### 16. Explain the role of `Spliterator` in streams.

**Answer:**  
`Spliterator` provides traversal and partitioning for parallel processing, splitting data for concurrent execution.

### 17. What are the benefits of `summaryStatistics`?

**Answer:**  
`summaryStatistics` computes count, sum, min, average, max in one pass, efficient for multiple stats without multiple traversals.

### 18. Discuss ordering guarantees in parallel streams.

**Answer:**  
Most parallel operations don't preserve encounter order. Exceptions: `forEachOrdered`, `findFirst`, ordered collectors. Use `unordered()` to hint order doesn't matter.

### 19. Explain infinite streams and how to handle them.

**Answer:**  
Infinite streams from `generate` or `iterate` run forever. Use short-circuiting like `limit` or `findFirst` to terminate.

### 20. What is the purpose of `peek` in debugging?

**Answer:**  
`peek` performs side effects (e.g., logging) without modifying the stream, useful for debugging pipelines.

### 21. Describe the `concat` method and its limitations.

**Answer:**  
`Stream.concat(a, b)` combines two streams sequentially. Both must be of the same type; not for parallel merging.

### 22. Explain the `partitioningBy` collector.

**Answer:**  
`partitioningBy(predicate)` splits elements into `Map<Boolean, List<T>>` based on predicate, simpler than `groupingBy` for booleans.

### 23. What are the risks of parallel streams?

**Answer:**  
Risks include overhead for small data, non-deterministic order, thread safety issues with shared state, and potential performance degradation.

### 24. Discuss the `unordered` hint.

**Answer:**  
`unordered()` allows optimizations by relaxing order constraints, but doesn't reorder; results may still be ordered.

### 25. Explain the difference between `takeWhile` and `dropWhile`.

**Answer:**  
`takeWhile` takes elements while predicate is true. `dropWhile` skips while true, then takes the rest. Both are Java 9+.

### 26. What is the combiner in collectors?

**Answer:**  
The combiner merges partial results from parallel threads into the final result.

### 27. Describe the `joining` collector.

**Answer:**  
`joining(delimiter, prefix, suffix)` concatenates strings with optional delimiter, prefix, suffix.

### 28. Explain why `distinct` is stateful.

**Answer:**  
`distinct` tracks seen elements to remove duplicates, requiring state across elements.

### 29. What are the forms of `iterate`?

**Answer:**  
`iterate(seed, f)` infinite; `iterate(seed, predicate, f)` finite until predicate false.

### 30. Discuss resource management in streams.

**Answer:**  
I/O streams (e.g., `Files.lines`) must be closed with try-with-resources to prevent leaks.

### 31. Explain the `boxed` method.

**Answer:**  
`boxed` converts primitive streams to object streams, e.g., for collections requiring objects.

### 32. What is the default behavior of `forEach` in parallel?

**Answer:**  
`forEach` doesn't guarantee order in parallel; use `forEachOrdered` for order.

### 33. Describe the `range` and `rangeClosed` methods.

**Answer:**  
`range(start, end)` exclusive end; `rangeClosed(start, end)` inclusive end, for generating number sequences.

### 34. Explain the importance of non-interference.

**Answer:**  
Non-interference ensures streams don't modify the source, preventing exceptions and ensuring predictability.

### 35. What is the role of `supplier` in `collect`?

**Answer:**  
Supplier creates the initial container for accumulation, e.g., `ArrayList::new`.

### 36. Discuss the `groupingByConcurrent` collector.

**Answer:**  
Similar to `groupingBy` but concurrent for parallel streams, though it doesn't preserve order.

### 37. Explain the `allMatch` operation.

**Answer:**  
`allMatch` returns true if all elements match the predicate, short-circuiting to false on first mismatch.

### 38. What are the limitations of `mapMulti`?

**Answer:**  
`mapMulti` (Java 16+) maps one element to multiple, more efficient than `flatMap` for some cases, but newer.

### 39. Describe the `close` method.

**Answer:**  
`close` releases resources for I/O streams, called automatically in try-with-resources.

### 40. Explain the `isParallel` method.

**Answer:**  
`isParallel` checks if the stream is in parallel mode.

### 41. What is the difference between `min` and `max`?

**Answer:**  
Both are terminal aggregates returning Optional<T> of the min/max element using comparator.

### 42. Discuss the `noneMatch` operation.

**Answer:**  
`noneMatch` returns true if no elements match the predicate, short-circuiting to false on first match.

### 43. Explain the `skip` operation.

**Answer:**  
`skip(n)` discards the first n elements, returning the rest.

### 44. What is the purpose of `onClose`?

**Answer:**  
`onClose` registers cleanup actions when the stream closes.

### 45. Describe the `summarizingInt` collector.

**Answer:**  
`summarizingInt` collects IntSummaryStatistics with count, sum, min, average, max.

### 46. Explain the `collectingAndThen` collector.

**Answer:**  
`collectingAndThen(collector, finisher)` applies a transformation after collection, e.g., making unmodifiable.

### 47. What are the risks of side effects in streams?

**Answer:**  
Side effects can cause non-determinism, especially in parallel, and violate functional principles.

### 48. Discuss the `asLongStream` method.

**Answer:**  
Converts `IntStream` to `LongStream` by casting.

### 49. Explain the `empty` stream.

**Answer:**  
`Stream.empty()` creates a stream with no elements, useful for defaults.

### 50. What is the theoretical foundation of streams?

**Answer:**  
Streams are based on functional programming, emphasizing immutability, laziness, and declarative operations over imperative loops.</content>
<parameter name="filePath">c:\Users\AD-071\Documents\Java-interview\java-collection-framework\java_streams_quiz.md